# Maximum Inner Product Search with Ball Tree

## 实现原理与细节

### Ball Tree上层算法相关

对于算法的基本结构，在论文中已经有相应的伪代码，这里就不重复了，主要讲一些算法实现细节，以及和存储模块对接处的细节。

#### BallTreeNode表示

由于算法中，BallTree的叶子和非叶子节点的存储数据略有不同，因此我们使用`BallTreeBranch`和`BallTreeLeaf`作为`BallTreeNode`的子类。其中：在`BallTreeNode`中存储Branch和Leaf共有的节点下的球心和球半径，在`BallTreeBranch`中额外存储树的左右指针，在`BallTreeNode`中额外存储树的叶子节点中所包含的**所有向量的RID值**。

这里我们选择在`BallTreeLeaf`中保存向量的RID，而不是向量本身的原因在于，由于向量本身消耗存储空间较大，如果保存全部20个向量数据在节点中，会造成节点非常的大，也就是说这样就不能把**树节点**全部保存在内存中，这样就会造成两个问题：1. 树遍历时会造成树本身结构较为违反直觉，对于实现来说是一个负担。2. 更重要的是，在Branch and Bound的时候，需要读取叶子节点的球心和半径，来决定是否对叶子节点进行访问，而如果叶子节点的大小过于臃肿，而从外存中读取进来，如果经过计算（MIP）后发现，这个节点实际上并不需要进行遍历，那么读取大量向量的时间就是浪费了的。基于这两点，我们在叶子节点中仅保留向量的RID

#### BallTreeNode的存储选择

由于所有树节点中所保存的数据相对较小（不包含真正的向量数据），因此我们选择把整棵球树在算法的全过程中保存在内存之中。这样做主要基于以下考虑：1. 实现方便，对于内存中树的遍历在visitor pattern的帮助下非常易于实现，遍历到叶子节点时，把所有向量从（逻辑上的）外存中取出（当然，也可能已经被保存在内存缓冲中了）进行计算就可以。2. 由于BallTree是二叉树，就算树的高度相对于数据量是对数级别，其高度也会是比较高的，所以在内存中对树的遍历会极大地降低IO的开销（或者说保存在外存中会极大增加开销）。而将树结构保存在内存中的一些顾虑包括对内存的占用是否过大，在经过粗略计算后发现，在Yahoo的约60万300维向量的数据下，使用这种表示的方法，对内存的消耗也仅有100M左右，尚在可以接受的范围内，因此将树节点完全保存在内存中是完全可行的。

#### BallTree算法：Build & Search

##### BuildTree

对于建树，算法上都是翻译伪代码来完成，没有什么新意。实现细节方面就比较注意地切分任务，使用不同的函数来进行半径、球心以及对节点的分裂，在测试时也会比较方便。另外就是充分利用Modern C++的特性，充分利用C++ Algorithm库的函数式序列操作的接口（`std::accumulate`, `std::transform`等）尽可能地简化代码，以及尽量地发挥移动语义对容器的作用，在分裂时使用`std::move_iterator`来构造新序列使得拷贝的开销降到最低。

##### Search

对于搜索，我们对论文中的算法进行了简单的修改，在论文中，Branch and Bound的操作是在遍历到一个节点的开头时进行，进入节点后对该节点下可能存在的最大内积，再决定是否进行搜索。这样做的问题在于，在决定遍历左右节点的次序时，已经计算过一遍子节点可能存在的最大内积了，计算可能的最大内积的开销是关于节点维度的O(n)，不过能省点就省点吧。因此把Branch and Bound的时机提前到遍历子节点之前，也就是决定遍历的优先次序时。由于遍历过一个子树过后，当前的最大内积值可能改变，因此当一个子树遍历返回后，需要再次进行判断来避免无意义的遍历。

至于遍历的具体实现，由于BallTreeNode具有两种表示形式（Branch和Leaf），因此这里使用模式匹配在面向对象中的一个实现方式，也就是visitor模式来对树进行遍历。visitor模式的一个经典应用场景也是对于内部表示形式不同的数据结构的遍历，遍历时的中间状态（当前最大内积等等）也可以保存在visitor的具体实现（`BallTreeSearcher`）内部。

#### 对存储模块接口

我们在设计时，将上层算法，和底层的存储部分完全分离开。算法部分仅通过`RecordStorage`这个接口与存储进行交互，分别是`Rid RecordStorage::Put(const Record&)`和`std::unique_ptr<Record> RecordStorage::Get(const Rid&)`。对于数据的这样在进行测试的时候，可以选择不同的RecordStorage的接口来对算法进行测试（`SimpleStorage`是用于测试的实现），这样可以在完全不依赖下层存储实现的情况下确认算法部分的正确性。（测试代码在`test-algorithm.cpp`中给出，依赖是gtest）

